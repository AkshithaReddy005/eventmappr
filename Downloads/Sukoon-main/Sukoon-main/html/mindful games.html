<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üßò</text></svg>">
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&family=Playfair+Display:wght@400;500;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"/>
<title>SoulSpace - Mindful Games & Puzzles</title>
  <style>
    :root {
      --primary: #6366f1;
      --primary-dark: #4338ca;
      --primary-light: #a5b4fc;
      --secondary: #ec4899;
      --accent: #f8fafc;
      --text: #f8fafc;
      --text-light: #e2e8f0;
      --bg: rgba(15, 23, 42, 0.85);
      --card-bg: rgba(30, 41, 59, 0.8);
      --border: rgba(148, 163, 184, 0.3);
      --success: #10b981;
      --warning: #f59e0b;
      --error: #ef4444;
      --shadow: 0 8px 32px 0 rgba(15, 23, 42, 0.4);
      --radius: 16px;
      --transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
    }
    
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    html, body {
      min-height: 100vh;
      font-family: 'Poppins', sans-serif;
      color: var(--text);
      overflow-x: hidden;
      scroll-behavior: smooth;
      background: var(--bg);
    }
    
    #bg-video {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      object-fit: cover;
      z-index: -2;
    }
    
    #bg-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: linear-gradient(135deg, rgba(15, 23, 42, 0.8) 0%, rgba(67, 56, 202, 0.6) 100%);
      z-index: -1;
      pointer-events: none;
    }
    
    /* Header Styles */
    header {
      background: rgba(15, 23, 42, 0.9);
      backdrop-filter: blur(12px);
      box-shadow: var(--shadow);
      position: fixed;
      width: 100%;
      top: 0;
      z-index: 1000;
      padding: 1rem 5%;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--border);
      transition: var(--transition);
    }
    
    .navbar-brand {
      display: flex;
      align-items: center;
      gap: 0.8rem;
      text-decoration: none;
      font-weight: 600;
      font-size: 1.4rem;
      color: var(--accent);
      letter-spacing: 0.5px;
      transition: var(--transition);
    }
    
    .navbar-brand:hover {
      color: var(--secondary);
      transform: translateY(-2px);
    }
    
    .logo {
      height: 36px;
      width: 36px;
      border-radius: 8px;
      transition: var(--transition);
    }
    
    .nav-links ul {
      display: flex;
      list-style: none;
      gap: 2rem;
    }
    
    .nav-links a {
      text-decoration: none;
      color: var(--text-light);
      font-weight: 500;
      font-size: 1rem;
      transition: var(--transition);
      position: relative;
      padding: 0.5rem 0;
    }
    
    .nav-links a::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      width: 0;
      height: 2px;
      background: var(--accent);
      transition: var(--transition);
    }
    
    .nav-links a:hover::after {
      width: 100%;
    }
    
    .nav-links a:hover {
      color: var(--accent);
    }
    
    /* Main Content */
    .container {
      max-width: 1200px;
      margin: 100px auto 60px auto;
      padding: 2rem;
      position: relative;
    }
    
    h1 {
      font-family: 'Playfair Display', serif;
      font-weight: 600;
      font-size: 3rem;
      color: var(--accent);
      margin-bottom: 1.5rem;
      text-align: center;
      position: relative;
      display: inline-block;
      left: 50%;
      transform: translateX(-50%);
    }
    
    h1::after {
      content: '';
      position: absolute;
      bottom: -10px;
      left: 0;
      width: 100%;
      height: 3px;
      background: linear-gradient(90deg, var(--primary), var(--secondary));
      border-radius: 3px;
    }
    
    .subtitle {
      text-align: center;
      font-size: 1.2rem;
      margin-bottom: 3rem;
      color: var(--text-light);
      max-width: 700px;
      margin-left: auto;
      margin-right: auto;
      line-height: 1.6;
      opacity: 0.9;
    }
    
    /* Games Grid */
    .games-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
      gap: 2rem;
      margin-top: 2rem;
    }
    
    .game-card {
      background: var(--card-bg);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 2rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 380px;
      transition: var(--transition);
      border: 1px solid var(--border);
      position: relative;
      overflow: hidden;
      z-index: 1;
      opacity: 0;
      transform: translateY(30px);
    }
    
    .game-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 5px;
      background: linear-gradient(90deg, var(--primary), var(--secondary));
      transition: height 0.3s ease;
    }
    
    .game-card:hover {
      transform: translateY(-10px) scale(1.02);
      box-shadow: 0 12px 32px rgba(15, 23, 42, 0.5);
      border-color: var(--accent);
    }
    
    .game-card:hover::before {
      height: 8px;
    }
    
    .game-card h2 {
      margin-top: 1rem;
      font-size: 1.6rem;
      margin-bottom: 1rem;
      color: var(--accent);
      font-family: 'Playfair Display', serif;
      position: relative;
      padding-bottom: 0.5rem;
      text-align: center;
    }
    
    .game-card h2::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 50px;
      height: 3px;
      background: var(--secondary);
      border-radius: 3px;
    }
    
    .game-description {
      color: var(--text-light);
      font-size: 1.05rem;
      margin-bottom: 1.5rem;
      text-align: center;
      line-height: 1.6;
      opacity: 0.9;
    }
    
    .game-content {
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      flex-grow: 1;
      justify-content: center;
    }
    
    /* Button Styles */
    button {
      background: linear-gradient(90deg, var(--primary) 0%, var(--secondary) 100%);
      color: white;
      border: none;
      border-radius: 10px;
      padding: 0.8rem 2rem;
      font-size: 1rem;
      font-weight: 500;
      cursor: pointer;
      transition: var(--transition);
      box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
      margin-top: 1rem;
    }
    
    button:hover {
      transform: translateY(-3px);
      box-shadow: 0 8px 20px rgba(99, 102, 241, 0.4);
    }
    
    button:active {
      transform: translateY(0);
    }
    
    /* Footer Styles */
    .footer {
      text-align: center;
      margin-top: 4rem;
      color: var(--text-light);
      font-size: 1.05rem;
      padding-top: 2rem;
      border-top: 1px solid var(--border);
    }
    
    .footer a {
      color: var(--accent);
      text-decoration: none;
      font-weight: 500;
      transition: var(--transition);
      position: relative;
    }
    
    .footer a::after {
      content: '';
      position: absolute;
      bottom: -2px;
      left: 0;
      width: 0;
      height: 2px;
      background: var(--accent);
      transition: var(--transition);
    }
    
    .footer a:hover::after {
      width: 100%;
    }
    
    .footer a:hover {
      color: var(--secondary);
    }
    
    /* Game Specific Styles */
    /* Mindful Breathing Game */
    #breathing-circle {
      width: 150px;
      height: 150px;
      background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
      border-radius: 50%;
      margin-bottom: 1.5rem;
      transition: all 4s cubic-bezier(0.5, 0, 0.5, 1);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.3rem;
      color: white;
      box-shadow: 0 8px 24px rgba(99, 102, 241, 0.3);
      border: 3px solid var(--accent);
      font-weight: 500;
      position: relative;
      overflow: hidden;
    }
    
    #breathing-instruction {
      font-size: 1.2rem;
      margin-bottom: 1rem;
      color: var(--accent);
      font-weight: 500;
      transition: var(--transition);
    }
    
    /* Memory Game */
    #memory-grid {
      display: grid;
      grid-template-columns: repeat(4, 60px);
      grid-gap: 0.8rem;
      justify-content: center;
      align-items: center;
      min-height: 180px;
      margin-bottom: 1rem;
      overflow: visible;
    }
    
    .memory-card {
      background: none;
      border-radius: 12px;
      box-shadow: none;
      cursor: pointer;
      position: relative;
      perspective: 800px;
      transition: box-shadow 0.2s;
      user-select: none;
      width: 60px;
      height: 80px;
      margin: 0.4rem;
      display: inline-block;
      overflow: visible;
    }
    
    .card-inner {
      width: 100%;
      height: 100%;
      transition: transform 0.6s;
      transform-style: preserve-3d;
      position: relative;
    }
    
    .memory-card.flipped .card-inner {
      transform: rotateY(180deg);
      z-index: 2;
    }
    
    .card-front, .card-back {
      width: 100%;
      height: 100%;
      position: absolute;
      top: 0; left: 0;
      backface-visibility: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2rem;
      border-radius: 12px;
    }
    
    .card-front {
      background: var(--accent);
      color: #333;
      transform: rotateY(180deg);
    }
    
    .card-back {
      background: var(--primary-dark);
      color: #fff;
    }
    
    .memory-card.matched {
      background: rgba(16, 185, 129, 0.2);
      color: var(--success);
      cursor: default;
      border-color: var(--success);
      box-shadow: 0 4px 16px rgba(16, 185, 129, 0.2);
      transform: rotateY(180deg) scale(0.95);
    }
    
    .memory-card.matched::after {
      content: '‚úì';
      position: absolute;
      top: -10px;
      right: -10px;
      width: 25px;
      height: 25px;
      background: var(--success);
      color: white;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.9rem;
      font-weight: bold;
    }
    
    /* Simon Game */
    .simon-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 1rem;
      margin-bottom: 1rem;
      width: 100%;
      max-width: 220px;
    }
    
    .simon-btn {
      aspect-ratio: 1/1;
      border-radius: 12px;
      border: none;
      cursor: pointer;
      transition: var(--transition);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      position: relative;
      overflow: hidden;
    }
    
    .simon-btn::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.3);
      opacity: 0;
      transition: var(--transition);
    }
    
    .simon-btn.active::after {
      opacity: 1;
    }
    
    /* Sudoku Game */
    #sudoku-grid {
      border-collapse: collapse;
      margin-bottom: 1rem;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
    }
    
    #sudoku-grid td {
      width: 40px;
      height: 40px;
      border: 1px solid var(--border);
      text-align: center;
      font-size: 1.2rem;
      font-weight: 500;
      transition: var(--transition);
      position: relative;
      background: rgba(248, 250, 252, 0.1);
    }
    
    #sudoku-grid td input {
      width: 100%;
      height: 100%;
      border: none;
      text-align: center;
      font-size: 1.2rem;
      font-weight: 500;
      background: transparent;
      outline: none;
      color: var(--text);
    }
    
    #sudoku-grid td.highlighted {
      background-color: rgba(99, 102, 241, 0.3);
    }
    
    #sudoku-grid td.error {
      color: var(--error);
      animation: shake 0.5s;
    }
    
    /* Whack-a-Mole Game */
    #whack-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 1rem;
      margin-bottom: 1rem;
      width: 100%;
      max-width: 300px;
    }
    
    .whack-hole {
      aspect-ratio: 1/1;
      background: var(--primary-dark);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      position: relative;
      overflow: hidden;
      transition: var(--transition);
    }
    
    .whack-mole {
      position: absolute;
      width: 70%;
      height: 70%;
      background: var(--secondary);
      border-radius: 50% 50% 0 0;
      bottom: -100%;
      transition: bottom 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
      color: white;
    }
    
    .whack-mole.up {
      bottom: 0;
    }
    
    /* Rock Paper Scissors */
    .rps-btns {
      display: flex;
      gap: 1rem;
      margin-bottom: 1rem;
    }
    
    .rps-btn {
      width: 70px;
      height: 70px;
      border-radius: 50%;
      border: none;
      background: var(--primary-dark);
      font-size: 2rem;
      cursor: pointer;
      transition: var(--transition);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--accent);
    }
    
    .rps-btn:hover {
      transform: translateY(-5px) scale(1.1);
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.15);
    }
    
    .rps-result {
      font-size: 1.2rem;
      font-weight: 600;
      margin-top: 1rem;
      text-align: center;
      min-height: 2rem;
      color: var(--accent);
    }
    
    .rps-affirmation {
      font-size: 1rem;
      color: var(--text-light);
      font-style: italic;
      margin-top: 0.5rem;
      text-align: center;
      max-width: 80%;
    }
    
    /* Status Messages */
    #memory-status,
    #simon-status,
    #sudoku-status,
    #whack-status,
    #rps-status {
      margin-bottom: 1rem;
      color: var(--accent);
      font-size: 1.1rem;
      font-weight: 500;
      text-align: center;
      min-height: 1.5rem;
    }
    
    /* Score Displays */
    .whack-score {
      font-size: 1.2rem;
      font-weight: 600;
      color: var(--accent);
      margin-top: 0.5rem;
    }
    
    /* Animations */
    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      20%, 60% { transform: translateX(-3px); }
      40%, 80% { transform: translateX(3px); }
    }
    
    @keyframes whack {
      0% { transform: scale(1); }
      50% { transform: scale(0.8); }
      100% { transform: scale(1); }
    }
    
    @keyframes float {
      0% { transform: translate(0, 0); }
      25% { transform: translate(5%, 5%); }
      50% { transform: translate(10%, 0); }
      75% { transform: translate(5%, -5%); }
      100% { transform: translate(0, 0); }
    }
    
    .pulse {
      animation: pulse 2s infinite;
    }
    
    /* Responsive Design */
    @media (max-width: 768px) {
      .container {
        margin: 90px auto 40px auto;
        padding: 1.5rem;
      }
      
      h1 {
        font-size: 2.2rem;
      }
      
      .subtitle {
        font-size: 1.1rem;
      }
      
      .games-grid {
        grid-template-columns: 1fr;
      }
      
      .nav-links ul {
        gap: 1rem;
      }
    }
    
    @media (max-width: 480px) {
      h1 {
        font-size: 1.8rem;
      }
      
      .subtitle {
        font-size: 1rem;
      }
      
      .game-card {
        padding: 1.5rem;
      }
      
      .nav-links ul {
        display: none;
      }
    }
    
    /* Scroll Animations */
    .game-card {
      opacity: 0;
      transform: translateY(40px);
      transition: opacity 0.7s cubic-bezier(0.23, 1, 0.32, 1), transform 0.7s cubic-bezier(0.23, 1, 0.32, 1);
    }
    .game-card.visible {
      opacity: 1;
      transform: translateY(0);
      z-index: 1;
    }
  </style>
</head>
<body>
  <!-- Background Video -->
  <video id="bg-video" autoplay loop muted playsinline>
    <source src="https://cdn.pixabay.com/video/2022/10/14/134791-760686019_tiny.mp4" type="video/mp4">
  </video>
  <!-- Overlay for readability -->
  <div id="bg-overlay"></div>

  <!-- Navbar -->
  <header>
    <a class="navbar-brand" href="../index.html">
      <span style="font-size: 2rem;">üßò</span>
      SoulSpace
    </a>
    <div class="nav-links">
      <ul>
        <li><a href="../index.html">HOME</a></li>
        <li><a href="#services">SERVICES</a></li>
        <li><a href="#faq">FAQ</a></li>
        <li><a href="#contact">CONTACT US</a></li>
      </ul>
    </div>
  </header>

  <!-- Main Content -->
  <div class="container">
    <h1 class="animate__animated animate__fadeIn">Mindful Games & Puzzles</h1>
    <div class="subtitle animate__animated animate__fadeIn animate__delay-1s">
      Engage your mind with these therapeutic games designed to promote focus, reduce stress, and bring moments of joy. Each activity is crafted to help you find your center while having fun.
    </div>

    <div class="games-grid">
      <!-- 1. Mindful Breathing Game -->
      <div class="game-card">
        <h2>Mindful Breathing</h2>
        <div class="game-description">
          Follow the circle as it expands and contracts. Breathe in as it grows, breathe out as it shrinks. A simple way to calm your mind and reduce stress.
        </div>
        <div class="game-content">
          <div id="breathing-container">
            <div id="breathing-circle">Start</div>
            <div id="breathing-instruction">Press Start to begin</div>
            <button id="start-breathing">Start Breathing</button>
          </div>
        </div>
      </div>

      <!-- 2. Memory Match Game -->
      <div class="game-card">
        <h2>Memory Match</h2>
        <div class="game-description">
          Flip the cards and find all the pairs. This classic game helps improve focus and memory in a relaxing way. Take your time and enjoy the process.
        </div>
        <div class="game-content">
          <div id="memory-game">
            <div id="memory-status">Press Start to begin</div>
            <div class="memory-grid" id="memory-grid"></div>
            <button id="start-memory">Start Game</button>
          </div>
        </div>
      </div>

      <!-- 3. Simon Says (Color Pattern) -->
      <div class="game-card">
        <h2>Simon Says</h2>
        <div class="game-description">
          Repeat the color pattern! This game boosts memory, focus, and reaction time in a playful way. Watch carefully and test your recall.
        </div>
        <div class="game-content">
          <div id="simon-game">
            <div id="simon-status">Press Start to begin</div>
            <div class="simon-grid">
              <button class="simon-btn" style="background:#ef4444;" data-color="red"></button>
              <button class="simon-btn" style="background:#f59e0b;" data-color="yellow"></button>
              <button class="simon-btn" style="background:#10b981;" data-color="green"></button>
              <button class="simon-btn" style="background:#6366f1;" data-color="blue"></button>
            </div>
            <button id="start-simon">Start Game</button>
          </div>
        </div>
      </div>

      <!-- 4. Mini Sudoku (4x4) -->
      <div class="game-card">
        <h2>Mini Sudoku 4x4</h2>
        <div class="game-description">
          Fill the grid so every row, column, and 2x2 box has numbers 1-4. A mindful logic challenge that's perfect for a quick mental workout.
        </div>
        <div class="game-content">
          <div id="sudoku-game">
            <table id="sudoku-grid"></table>
            <div id="sudoku-status">Press Start to begin</div>
            <div class="sudoku-controls">
              <button id="start-sudoku">New Game</button>
              <button id="check-sudoku">Check</button>
            </div>
          </div>
        </div>
      </div>

      <!-- 5. Whack-a-Mole (Relaxing) -->
      <div class="game-card">
        <h2>Whack-a-Mole</h2>
        <div class="game-description">
          Tap the smiley as it appears! A light, mindful reflex game with no stress, just fun. See how many you can catch in 30 seconds.
        </div>
        <div class="game-content">
          <div id="whack-game">
            <div id="whack-grid"></div>
            <div id="whack-status">Press Start to begin</div>
            <div class="whack-score">Score: <span id="whack-score">0</span></div>
            <button id="start-whack">Start Game</button>
          </div>
        </div>
      </div>

      <!-- 6. Rock-Paper-Scissors with Affirmations -->
      <div class="game-card">
        <h2>Rock-Paper-Scissors</h2>
        <div class="game-description">
          Play against the computer. Win or lose, you'll receive a positive affirmation to brighten your day. It's all about having fun!
        </div>
        <div class="game-content">
          <div id="rps-game">
            <div id="rps-status">Choose your move!</div>
            <div class="rps-btns">
              <button class="rps-btn" data-move="rock">‚úä</button>
              <button class="rps-btn" data-move="paper">‚úã</button>
              <button class="rps-btn" data-move="scissors">‚úåÔ∏è</button>
            </div>
            <div class="rps-result" id="rps-result"></div>
            <div class="rps-affirmation" id="rps-affirmation"></div>
          </div>
        </div>
      </div>
    </div>

    <div class="footer">
      <a href="../index.html">Explore more SoulSpace services</a>
      <br><br>
      &copy; 2025 SoulSpace. Breathe. Play. Relax.
    </div>
  </div>

  <script>
    // Scroll-based animation for .game-card
    document.addEventListener('DOMContentLoaded', function() {
      const cards = document.querySelectorAll('.game-card');
      const observer = new IntersectionObserver((entries, obs) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            entry.target.classList.add('visible');
            entry.target.classList.add('animate__animated', 'animate__fadeInUp');
            obs.unobserve(entry.target);
          }
        });
      }, { threshold: 0.2 });
      cards.forEach(card => {
        observer.observe(card);
      });
    });

    // Scroll Animation
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          entry.target.classList.add('visible');
        }
      });
    }, { threshold: 0.1 });

    document.querySelectorAll('.game-card').forEach(card => {
      observer.observe(card);
    });

    // 1. Mindful Breathing Game
    const breathingCircle = document.getElementById('breathing-circle');
    const breathingInstruction = document.getElementById('breathing-instruction');
    const startBreathingBtn = document.getElementById('start-breathing');
    let breathingInterval, breathingStep = 0;
    const breathingSteps = [
      {text: 'Breathe In', scale: 1.6, duration: 4000, color: '#6366f1'},
      {text: 'Hold', scale: 1.6, duration: 3000, color: '#4338ca'},
      {text: 'Breathe Out', scale: 1, duration: 5000, color: '#a5b4fc'},
      {text: 'Hold', scale: 1, duration: 2000, color: '#ec4899'}
    ];

    function runBreathing() {
      const step = breathingSteps[breathingStep];
      breathingCircle.style.transform = `scale(${step.scale})`;
      breathingCircle.style.backgroundColor = step.color;
      breathingInstruction.textContent = step.text;
      breathingCircle.textContent = step.text;
      breathingCircle.className = step.text === 'Breathe In' ? 'breathing-in' : '';
      
      breathingStep = (breathingStep + 1) % breathingSteps.length;
      breathingInterval = setTimeout(runBreathing, step.duration);
    }

    startBreathingBtn.onclick = function() {
      if (startBreathingBtn.textContent === 'Start Breathing') {
        clearTimeout(breathingInterval);
        breathingStep = 0;
        runBreathing();
        startBreathingBtn.textContent = 'Pause';
      } else {
        clearTimeout(breathingInterval);
        breathingCircle.style.transform = 'scale(1)';
        breathingInstruction.textContent = 'Paused';
        breathingCircle.textContent = 'Paused';
        startBreathingBtn.textContent = 'Resume';
      }
    };

    // 2. Memory Match Game
    const memoryGrid = document.getElementById('memory-grid');
    const memoryStatus = document.getElementById('memory-status');
    const startMemoryBtn = document.getElementById('start-memory');
    let memoryCards = [], memoryFlipped = [], memoryMatched = 0, memoryLock = false;
    const memoryEmojis = ['üå±','üå∏','üåû','üåª','üçÄ','üçÑ','üçÅ','üåº'];

    function shuffle(array) {
      for(let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }

    function resetMemoryGame() {
      memoryCards = [];
      memoryFlipped = [];
      memoryMatched = 0;
      memoryLock = false;
      memoryStatus.textContent = 'Find all pairs!';
      
      let pairs = [...memoryEmojis, ...memoryEmojis];
      shuffle(pairs);
      
      memoryGrid.innerHTML = '';
      
      pairs.forEach((emoji, i) => {
        const card = document.createElement('div');
        card.className = 'memory-card';
        card.dataset.index = i;
        card.dataset.emoji = emoji;

        const cardInner = document.createElement('div');
        cardInner.className = 'card-inner';
        const cardFront = document.createElement('div');
        cardFront.className = 'card-front';
        cardFront.textContent = emoji;
        const cardBack = document.createElement('div');
        cardBack.className = 'card-back';
        cardBack.textContent = '';
        cardInner.appendChild(cardFront);
        cardInner.appendChild(cardBack);
        card.appendChild(cardInner);

        card.onclick = function() {
          if (memoryLock || card.classList.contains('flipped') || card.classList.contains('matched')) return;
          card.classList.add('flipped');
          memoryFlipped.push(card);
          if (memoryFlipped.length === 2) {
            memoryLock = true;
            setTimeout(() => {
              if (memoryFlipped[0].dataset.emoji === memoryFlipped[1].dataset.emoji) {
                memoryFlipped[0].classList.add('matched');
                memoryFlipped[1].classList.add('matched');
                memoryMatched++;
                if (memoryMatched === memoryEmojis.length) {
                  memoryStatus.textContent = 'You did it! üéâ';
                  setTimeout(() => {
                    memoryStatus.textContent = 'Play again?';
                  }, 2000);
                }
              } else {
                memoryFlipped[0].classList.remove('flipped');
                memoryFlipped[1].classList.remove('flipped');
              }
              memoryFlipped = [];
              memoryLock = false;
            }, 800);
          }
        };

        memoryGrid.appendChild(card);
      });
    }

    startMemoryBtn.onclick = resetMemoryGame;

    // 3. Simon Says Game
    const simonBtns = document.querySelectorAll('.simon-btn');
    const simonStatus = document.getElementById('simon-status');
    const startSimonBtn = document.getElementById('start-simon');
    let simonSequence = [], userSequence = [], level = 0, isPlaying = false;

    function activateButton(color) {
      const btn = document.querySelector(`.simon-btn[data-color="${color}"]`);
      btn.classList.add('active');
      setTimeout(() => {
        btn.classList.remove('active');
      }, 300);
    }

    function playSequence() {
      userSequence = [];
      isPlaying = false;
      simonStatus.textContent = `Level ${level + 1}`;
      
      let i = 0;
      const interval = setInterval(() => {
        activateButton(simonSequence[i]);
        i++;
        if (i >= simonSequence.length) {
          clearInterval(interval);
          isPlaying = true;
          simonStatus.textContent = 'Your turn!';
        }
      }, 800);
    }

    function nextLevel() {
      level++;
      userSequence = [];
      const colors = ['red', 'yellow', 'green', 'blue'];
      simonSequence.push(colors[Math.floor(Math.random() * colors.length)]);
      playSequence();
    }

    function startSimonGame() {
      simonSequence = [];
      level = 0;
      nextLevel();
    }

    simonBtns.forEach(btn => {
      btn.addEventListener('click', function() {
        if (!isPlaying) return;
        
        const color = this.dataset.color;
        activateButton(color);
        userSequence.push(color);
        
        if (userSequence[userSequence.length - 1] !== simonSequence[userSequence.length - 1]) {
          simonStatus.textContent = 'Game Over! Try again.';
          isPlaying = false;
          setTimeout(() => {
            startSimonGame();
          }, 1500);
          return;
        }
        
        if (userSequence.length === simonSequence.length) {
          setTimeout(() => {
            nextLevel();
          }, 1000);
        }
      });
    });

    startSimonBtn.onclick = startSimonGame;

    // 4. Sudoku Game
    const sudokuGrid = document.getElementById('sudoku-grid');
    const sudokuStatus = document.getElementById('sudoku-status');
    const startSudokuBtn = document.getElementById('start-sudoku');
    const checkSudokuBtn = document.getElementById('check-sudoku');
    let sudokuBoard = [];

    function createSudokuBoard() {
      sudokuGrid.innerHTML = '';
      sudokuBoard = [];
      
      for (let i = 0; i < 4; i++) {
        const row = document.createElement('tr');
        sudokuBoard[i] = [];
        
        for (let j = 0; j < 4; j++) {
          const cell = document.createElement('td');
          const input = document.createElement('input');
          input.type = 'text';
          input.maxLength = 1;
          input.dataset.row = i;
          input.dataset.col = j;
          
          input.addEventListener('input', function() {
            this.value = this.value.replace(/[^1-4]/g, '');
            sudokuBoard[i][j] = this.value ? parseInt(this.value) : 0;
          });
          
          input.addEventListener('focus', function() {
            highlightRelatedCells(i, j);
          });
          
          cell.appendChild(input);
          row.appendChild(cell);
          sudokuBoard[i][j] = 0;
        }
        
        sudokuGrid.appendChild(row);
      }
      
      generateSudokuPuzzle();
      sudokuStatus.textContent = 'Fill the grid with numbers 1-4';
    }

    function highlightRelatedCells(row, col) {
      const cells = sudokuGrid.querySelectorAll('td');
      cells.forEach(cell => cell.classList.remove('highlighted'));
      
      for (let j = 0; j < 4; j++) {
        sudokuGrid.rows[row].cells[j].classList.add('highlighted');
      }
      
      for (let i = 0; i < 4; i++) {
        sudokuGrid.rows[i].cells[col].classList.add('highlighted');
      }
      
      const boxRow = Math.floor(row / 2) * 2;
      const boxCol = Math.floor(col / 2) * 2;
      
      for (let i = boxRow; i < boxRow + 2; i++) {
        for (let j = boxCol; j < boxCol + 2; j++) {
          sudokuGrid.rows[i].cells[j].classList.add('highlighted');
        }
      }
    }

    function generateSudokuPuzzle() {
      const solvedBoard = [
        [1, 2, 3, 4],
        [3, 4, 1, 2],
        [2, 1, 4, 3],
        [4, 3, 2, 1]
      ];
      
      for (let i = 0; i < 4; i++) {
        for (let j = 0; j < 4; j++) {
          sudokuBoard[i][j] = solvedBoard[i][j];
        }
      }
      
      let cellsToRemove = 8;
      while (cellsToRemove > 0) {
        const row = Math.floor(Math.random() * 4);
        const col = Math.floor(Math.random() * 4);
        
        if (sudokuBoard[row][col] !== 0) {
          sudokuBoard[row][col] = 0;
          sudokuGrid.rows[row].cells[col].querySelector('input').value = '';
          cellsToRemove--;
        }
      }
    }

    function checkSudokuSolution() {
      for (let i = 0; i < 4; i++) {
        const row = new Set();
        for (let j = 0; j < 4; j++) {
          if (sudokuBoard[i][j] === 0 || row.has(sudokuBoard[i][j])) {
            markErrorsInRow(i);
            sudokuStatus.textContent = 'There are errors in row ' + (i + 1);
            return false;
          }
          row.add(sudokuBoard[i][j]);
        }
      }
      
      for (let j = 0; j < 4; j++) {
        const col = new Set();
        for (let i = 0; i < 4; i++) {
          if (sudokuBoard[i][j] === 0 || col.has(sudokuBoard[i][j])) {
            markErrorsInColumn(j);
            sudokuStatus.textContent = 'There are errors in column ' + (j + 1);
            return false;
          }
          col.add(sudokuBoard[i][j]);
        }
      }
      
      for (let boxRow = 0; boxRow < 4; boxRow += 2) {
        for (let boxCol = 0; boxCol < 4; boxCol += 2) {
          const box = new Set();
          for (let i = boxRow; i < boxRow + 2; i++) {
            for (let j = boxCol; j < boxCol + 2; j++) {
              if (sudokuBoard[i][j] === 0 || box.has(sudokuBoard[i][j])) {
                markErrorsInBox(boxRow, boxCol);
                sudokuStatus.textContent = 'There are errors in one of the 2x2 boxes';
                return false;
              }
              box.add(sudokuBoard[i][j]);
            }
          }
        }
      }
      
      for (let i = 0; i < 4; i++) {
        for (let j = 0; j < 4; j++) {
          if (sudokuBoard[i][j] === 0) {
            sudokuStatus.textContent = 'Not all cells are filled yet';
            return false;
          }
        }
      }
      
      sudokuStatus.textContent = 'Congratulations! Puzzle solved correctly!';
      return true;
    }

    function markErrorsInRow(row) {
      for (let j = 0; j < 4; j++) {
        sudokuGrid.rows[row].cells[j].classList.add('error');
      }
      setTimeout(() => {
        for (let j = 0; j < 4; j++) {
          sudokuGrid.rows[row].cells[j].classList.remove('error');
        }
      }, 1000);
    }

    function markErrorsInColumn(col) {
      for (let i = 0; i < 4; i++) {
        sudokuGrid.rows[i].cells[col].classList.add('error');
      }
      setTimeout(() => {
        for (let i = 0; i < 4; i++) {
          sudokuGrid.rows[i].cells[col].classList.remove('error');
        }
      }, 1000);
    }

    function markErrorsInBox(startRow, startCol) {
      for (let i = startRow; i < startRow + 2; i++) {
        for (let j = startCol; j < startCol + 2; j++) {
          sudokuGrid.rows[i].cells[j].classList.add('error');
        }
      }
      setTimeout(() => {
        for (let i = startRow; i < startRow + 2; i++) {
          for (let j = startCol; j < startCol + 2; j++) {
            sudokuGrid.rows[i].cells[j].classList.remove('error');
          }
        }
      }, 1000);
    }

    startSudokuBtn.onclick = createSudokuBoard;
    checkSudokuBtn.onclick = checkSudokuSolution;

    // 5. Whack-a-Mole Game
    const whackGrid = document.getElementById('whack-grid');
    const whackStatus = document.getElementById('whack-status');
    const whackScoreDisplay = document.getElementById('whack-score');
    const startWhackBtn = document.getElementById('start-whack');
    let whackScore = 0, whackGameInterval, whackTimeLeft = 30;

    function createWhackGame() {
      whackGrid.innerHTML = '';
      whackScore = 0;
      whackScoreDisplay.textContent = '0';
      whackTimeLeft = 30;
      
      for (let i = 0; i < 9; i++) {
        const hole = document.createElement('div');
        hole.className = 'whack-hole';
        
        const mole = document.createElement('div');
        mole.className = 'whack-mole';
        mole.textContent = 'üòä';
        
        hole.appendChild(mole);
        whackGrid.appendChild(hole);
        
        mole.addEventListener('click', function() {
          if (mole.classList.contains('up')) {
            mole.classList.remove('up');
            mole.classList.add('whacked');
            whackScore++;
            whackScoreDisplay.textContent = whackScore;
            
            setTimeout(() => {
              mole.classList.remove('whacked');
            }, 300);
          }
        });
      }
      
      whackStatus.textContent = 'Game started! Whack the moles!';
      startWhackBtn.textContent = 'Playing...';
      startWhackBtn.disabled = true;
      
      const timerDisplay = document.createElement('div');
      timerDisplay.className = 'whack-timer';
      timerDisplay.textContent = `Time: ${whackTimeLeft}s`;
      whackStatus.parentNode.insertBefore(timerDisplay, whackStatus.nextSibling);
      
      const timer = setInterval(() => {
        whackTimeLeft--;
        timerDisplay.textContent = `Time: ${whackTimeLeft}s`;
        
        if (whackTimeLeft <= 0) {
          clearInterval(timer);
          clearInterval(whackGameInterval);
          whackStatus.textContent = `Game Over! Your score: ${whackScore}`;
          startWhackBtn.textContent = 'Play Again';
          startWhackBtn.disabled = false;
        }
      }, 1000);
      
      whackGameInterval = setInterval(() => {
        const holes = document.querySelectorAll('.whack-hole');
        const randomIndex = Math.floor(Math.random() * holes.length);
        const mole = holes[randomIndex].querySelector('.whack-mole');
        
        mole.classList.add('up');
        
        setTimeout(() => {
          if (mole.classList.contains('up')) {
            mole.classList.remove('up');
          }
        }, 1000);
      }, 800);
    }

    startWhackBtn.onclick = createWhackGame;

    // 6. Rock-Paper-Scissors Game
    const rpsStatus = document.getElementById('rps-status');
    const rpsResult = document.getElementById('rps-result');
    const rpsAffirmation = document.getElementById('rps-affirmation');
    const rpsButtons = document.querySelectorAll('.rps-btn');
    const rpsChoices = ['rock', 'paper', 'scissors'];
    const affirmations = [
      "You're doing great! Keep it up!",
      "Every game is a chance to learn and grow!",
      "Your positive energy is contagious!",
      "You're stronger than you think!",
      "Mistakes are just stepping stones to success!",
      "Your potential is limitless!",
      "You bring joy to those around you!",
      "Every day is a fresh start!"
    ];

    function getRandomAffirmation() {
      return affirmations[Math.floor(Math.random() * affirmations.length)];
    }

    function playRPS(playerChoice) {
      const computerChoice = rpsChoices[Math.floor(Math.random() * 3)];
      let result;
      
      if (playerChoice === computerChoice) {
        result = "It's a tie!";
      } else if (
        (playerChoice === 'rock' && computerChoice === 'scissors') ||
        (playerChoice === 'paper' && computerChoice === 'rock') ||
        (playerChoice === 'scissors' && computerChoice === 'paper')
      ) {
        result = "You win!";
      } else {
        result = "Computer wins!";
      }
      
      rpsResult.textContent = `You chose ${playerChoice}, computer chose ${computerChoice}. ${result}`;
      rpsAffirmation.textContent = getRandomAffirmation();
    }

    rpsButtons.forEach(button => {
      button.addEventListener('click', function() {
        playRPS(this.dataset.move);
      });
    });
  </script>
</body>
</html>